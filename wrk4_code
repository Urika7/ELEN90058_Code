#include "Params.h"
#include "SPWS4.h"

complex_fract32 twiddle[N] = { 0 };
complex_fract32 filter_fft[N] = { 0 };

complex_fract32 input_freq[N] = { 0 };
complex_fract32 output_freq[N] = { 0 };
complex_fract32 output_fft[N] = { 0 };

float r[N+M+K-1] = {0};

void AddCyclicPrefix()
{
	// TODO: 1. Attach the cyclic prefix to the data block (the x[] array)

	//Copy last K values of d[n] onto start of x[n]
	for(int n = 0; n < K; n++){
		x[n] = x[N+n];
	}

}

void process_block(fract32 output[])
{
	// TODO: 2. Recover the input signal using the algorithm
	// introduced in Question 2

	// First, you need to create the y array from r
	// Note: the y[] array in the algorithm should be defined frac32.
	fract32 y[N] = {0};
	for(int i = 0; i < N; i++)
	{
		y[i] = r[i+K];
	}
	//Find FFT of y
	int blk_exp;
	rfft_fr32(y, input_freq, twiddle, 1, N, &blk_exp, 1);

	//Divide by H[k]
	for (int i = 0; i < N; i++){
		output_freq[i] = cdiv_fr32(input_freq[i], filter_fft[i]);
	}

	ifft_fr32(output_freq, output_fft, twiddle, 1, N, &blk_exp, 1);

	for (int i = 0; i < N; i++){
		output[i] = output_fft[i].re << blk_exp;
	}
}

void process_time()
{
	r[0] = x[0]*b[0];
	r[1] = x[1]*b[0]+x[0]*b[1];
    for (int i = 2;i < N+M+K-1;i++)
	{
    	r[i] = x[i]*b[0]+x[i-1]*b[1]+x[i-2]*b[2];
	}
}

void init_process()
{
    int i;

    // calculate twiddle factors
    twidfftrad2_fr32(twiddle, N);

    // copy filter coefficients to input array to do fft
    for (i = 0; i < M; i++)
    {
    	input_data[i] = (1 << 30) * b[i];
    }

    	//input_data[i] = b[i];
        // [ note ]
        // Here we should scale by (1 << 31)-1 for full scale, however
        // doing so can cause overflows in fixed point, so we halve it
        // here and put back the factor 2 on output.

    // do fft
    int filter_blk_exp;
    rfft_fr32(input_data, filter_fft, twiddle, 1, N, &filter_blk_exp, 1);

    // rescale data points
    for (i = 0; i < N; i++)
    {
        filter_fft[i].re = filter_fft[i].re << (filter_blk_exp);
        filter_fft[i].im = filter_fft[i].im << (filter_blk_exp);
    }

    // clear input array
    for (i = 0; i < M; i++)
        input_data[i] = 0;
}
